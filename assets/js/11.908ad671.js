(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{581:function(n,e,a){"use strict";a.r(e);var t=a(17),l=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"什么是深浅拷贝-如何实现深浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是深浅拷贝-如何实现深浅拷贝"}},[n._v("#")]),n._v(" 什么是深浅拷贝？如何实现深浅拷贝")]),n._v(" "),a("p",[n._v("在聊深浅拷贝之前，先聊一下js数据类型，可以分为"),a("strong",[n._v("值类型(基本类型)")]),n._v(" 和 "),a("strong",[n._v("引用数据类型（对象类型）")]),n._v(" JS中的变量都是保存到栈内存中的 "),a("strong",[n._v("基本数据类型")]),n._v(" 的值直接在栈内存中存储，值与值之间是独立存在，"),a("strong",[n._v("引用数据类型")]),n._v(" 是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而栈里面保存的是对象的内存地址(对象的引用)")]),n._v(" "),a("p",[n._v("例如下面代码，在内存中大概存这样")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let a = 2\nlet c = 'hello'\nlet obj1 = {\n  name:'obj'\n}\nlet obj2 = obj\n")])])]),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/480943ad88fb4f37880601237f4ddefb~tplv-k3u1fbpfcp-watermark.image?",alt:"@_Q69ASZ_DPY$W_OY(4V{85.png"}}),n._v(" "),a("strong",[n._v("赋值和深浅拷贝的区别")]),n._v(" 之前，我一直认为赋值就是浅拷贝，现在发现是错的，赋值对于基本类型来说可以认为是浅拷贝，（基本类型没有深浅拷贝）。")]),n._v(" "),a("p",[a("strong",[n._v("浅拷贝")]),n._v(" 浅拷贝是指创建一个新的对象，把这个对象的原始属性精确拷贝一份，如果是基本类型就拷贝基本类似的值，如果是引用类型，拷贝的就是内存地址，如果其中一个引用类型改变了值，那么就会影响另一个对象")]),n._v(" "),a("p",[a("strong",[n._v("深拷贝")]),n._v(" 深拷贝是将一个对象从内存中完成拷贝出来，在内存中开辟一个新的区域存放对象，并且两者不会相互影响")]),n._v(" "),a("h2",{attrs:{id:"赋值方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#赋值方法"}},[n._v("#")]),n._v(" 赋值方法")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const obj1 = {\n  name: \"www\",\n  age: 18\n};\nlet obj2 = obj1;\nobj2.age = 20;\nconsole.log(obj1, obj2);\n// 可以看到将obj1 赋值 给obj2 修改obj2的值obj1也会变\n// { name: 'www' age: 18 } { name:'www' age: 20, }\n")])])]),a("h2",{attrs:{id:"浅拷贝方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝方法"}},[n._v("#")]),n._v(" 浅拷贝方法")]),n._v(" "),a("ul",[a("li",[n._v("Object.assign() 对象浅拷贝")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const obj1 = {\n  name: \"www\",\n  age: 18\n};\nlet obj2 = Object.assign({}, obj1);\nobj2.age = 20;\nconsole.log(obj1, obj2);\n// 可以看到浅拷贝修改之后age的变更并不会相互影响\n//{ name: 'www' age: 18 } { name:'www' age: 20, }\n")])])]),a("p",[n._v("看到这里是不是觉得修改新对象的值旧对象不会改变还算浅拷贝吗？如果你也有这样的疑问，那么请往下看")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const obj1 = {\n  name: \"www\",\n  age: 18,\n  hobby: {\n    ball: 'basketball',\n    track: 'running'\n  }\n};\nlet obj2 = Object.assign({}, obj1);\nobj2.age = 20;\nobj2.hobby.ball = 'volleyball'\nconsole.log(obj1, obj2);\n// { name: 'www', age: 18, hobby: { ball: 'volleyball', track: 'running' } }\n// { name: 'www', age: 20, hobby: { ball: 'volleyball', track: 'running' } }\n")])])]),a("p",[n._v("这发现里修改了新对象hobby对象里面的ball值旧对象也会跟着改")]),n._v(" "),a("blockquote",[a("p",[n._v("其实"),a("strong",[n._v("Object.assign()")]),n._v(" 拷贝 当对象中只有一级属性,没有二级属性的时候,此方法为"),a("em",[n._v("深拷贝")]),n._v(",但是对象中有对象的时候,此方法,在二级属性以后就"),a("em",[n._v("是浅拷贝")]),n._v("。")])]),n._v(" "),a("ul",[a("li",[a("strong",[n._v("...")]),n._v(" 展开运算符  解构浅拷贝")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const obj1 = {\n  name: \"www\",\n  age: 18,\n  hobby: {\n    ball: 'basketball',\n    track: 'running'\n  }\n};\nlet obj2 = { ...obj1 };\nobj2.age = 20;\nobj2.hobby.ball = 'volleyball'\nconsole.log(obj1, obj2);\n// { name: 'www', age: 18, hobby: { ball: 'volleyball', track: 'running' } }\n// { name: 'www', age: 20, hobby: { ball: 'volleyball', track: 'running' } }\n")])])]),a("blockquote",[a("p",[n._v("该方法和 "),a("strong",[n._v("Object.assign()")]),n._v(" 效果差不多")])]),n._v(" "),a("ul",[a("li",[n._v("手动实现一个浅拷贝")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function clone(source) {\n  if (typeof source === \"object\") {\n    let target = Array.isArray(source) ? [] : {};\n    for (let i in source) {\n      if (source.hasOwnProperty(i)) {\n        // source.hasOwnProperty(i)意思是_proto_上面的属性我们不拷贝\n        target[i] = source[i];\n      }\n    }\n    return target;\n  } else {\n    return target;\n  }\n}\nconst obj1 = {\n  name: \"www\",\n  age: 18,\n  hobby: {\n    ball: 'basketball',\n    track: 'running'\n  }\n};\nlet obj2 = clone(obj1);\nobj2.age = 20;\nobj2.hobby.ball = 'volleyball'\nconsole.log(obj1, obj2);\n// { name: 'www', age: 18, hobby: { ball: 'volleyball', track: 'running' } }\n// { name: 'www', age: 20, hobby: { ball: 'volleyball', track: 'running' } }\n")])])]),a("h2",{attrs:{id:"深拷贝方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝方法"}},[n._v("#")]),n._v(" 深拷贝方法")]),n._v(" "),a("ul",[a("li",[n._v("简单的方法 JSON.parse(JSON.stringify())\n只适用于固定的数据结构"),a("br"),n._v("\n这种方法虽然可以实现数组或对象深拷贝,但是有几种情况不能正确进行深拷贝")])]),n._v(" "),a("ol",[a("li",[n._v("obj里面有new Date(),深拷贝后，时间会变成字符串形式，而不是时间对象")]),n._v(" "),a("li",[n._v("obj⾥有RegExp、Error对象，则序列化的结果会变成空对象{}")]),n._v(" "),a("li",[n._v("obj⾥有function，undefined，则序列化的结果会把function或 undefined丢失")]),n._v(" "),a("li",[n._v("obj里有NaN、Infinity、-Infinity，则序列化的结果会变成null")]),n._v(" "),a("li",[n._v("JSON.string()只能序列化对象的可枚举的自有属性，如果obj中的对象是由构造函数生成的实例对象，深拷贝后会丢失对象的constructor\n"),a("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c8cdcc01cc4bdb931489a00d2c95c5~tplv-k3u1fbpfcp-watermark.image?",alt:"3.png"}})])]),n._v(" "),a("ul",[a("li",[n._v("lodash 库的_.cloneDeep")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let _ = require(\"lodash\");\nlet obj1 = {\n  a: 1,\n  b: { d: { e: 1, f: '123' } },\n  c: [1, 2, 3],\n};\nlet obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f); // false\n")])])]),a("ul",[a("li",[n._v("手动实现一个简单深拷贝")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function deepClone(obj) {\n  //定义一个函数判断参数是否是对象\n  function isObject(o) {\n    return (typeof o == 'object' || typeof o == 'function') && o !== null\n  }\n  if (!isObject(obj)) { //如果不是对象\n    // throw new Error('非对象')\n  }\n  let isArray = Array.isArray(obj)\n  let newObj = isArray ? [...obj] : { ...obj }\n  //遍历newObj 此时如果newObj是对象key为对象的key 如果是数字 key 为数组的下标\n  Object.keys(newObj).forEach(key => {\n    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n  })\n\n  return newObj\n}\nlet obj = {\n  a: [1, 2, 3],\n  b: {\n    c: 2,\n    d: 3\n  }\n}\nlet newObj = deepClone(obj)\nnewObj.b.c = 1\nconsole.log(obj); //{ a: [ 1, 2, 3 ], b: { c: 2, d: 3 } }\nconsole.log(newObj); //{ a: [ 1, 2, 3 ], b: { c: 1, d: 3 } }\n")])])])])}),[],!1,null,null,null);e.default=l.exports}}]);